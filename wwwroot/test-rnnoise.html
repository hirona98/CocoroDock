<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RNNoise Processor Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            text-align: center;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.warning { background-color: #fff3cd; color: #856404; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-warning { background-color: #ffc107; color: black; }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
        }

        .value-display {
            font-size: 12px;
            color: #777;
        }

        .audio-visualization {
            height: 100px;
            background: linear-gradient(to right, #e3f2fd, #2196f3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }

        .audio-level-bar {
            height: 100%;
            background: linear-gradient(to right, #4caf50, #ffeb3b, #f44336);
            transition: width 0.1s ease;
            border-radius: 8px;
        }

        .vad-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            transition: all 0.3s;
        }

        .vad-indicator.speech {
            background-color: #4caf50;
            animation: pulse 1s infinite;
        }

        .vad-indicator.silence {
            background-color: #757575;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.error {
            color: #dc3545;
            font-weight: bold;
        }

        .recorded-audio {
            margin-top: 10px;
            padding: 10px;
            background: #e8f5e8;
            border-radius: 4px;
            border-left: 4px solid #28a745;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }

            .settings {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ RNNoise Processor Test</h1>

        <div id="status" class="status info">
            åˆæœŸåŒ–å¾…æ©Ÿä¸­...
        </div>

        <div class="controls">
            <button id="initBtn" class="btn-primary">åˆæœŸåŒ–</button>
            <button id="startBtn" class="btn-success" disabled>éŒ²éŸ³é–‹å§‹</button>
            <button id="stopBtn" class="btn-danger" disabled>éŒ²éŸ³åœæ­¢</button>
            <button id="testBtn" class="btn-warning" disabled>éŸ³å£°ãƒ†ã‚¹ãƒˆ</button>
            <button id="debugBtn" class="btn-primary">ãƒ‡ãƒãƒƒã‚°åˆ‡æ›¿</button>
            <button id="clearLogBtn" class="btn-warning">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
        </div>

        <div class="settings">
            <div class="setting-item">
                <label for="vadThreshold">VADé–¾å€¤</label>
                <input type="range" id="vadThreshold" min="0" max="1" step="0.01" value="0.6">
                <div class="value-display" id="vadThresholdValue">0.6</div>
            </div>

            <div class="setting-item">
                <label for="silenceTimeout">ç„¡éŸ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (ms)</label>
                <input type="range" id="silenceTimeout" min="100" max="2000" step="50" value="500">
                <div class="value-display" id="silenceTimeoutValue">500ms</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°å¯è¦–åŒ–</h2>
        <div class="audio-visualization">
            <div id="audioLevelBar" class="audio-level-bar" style="width: 0%;"></div>
            <div id="vadIndicator" class="vad-indicator silence">ç„¡éŸ³</div>
        </div>
    </div>

    <div class="container">
        <h2>ğŸ“ˆ çµ±è¨ˆæƒ…å ±</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">å‡¦ç†ãƒ•ãƒ¬ãƒ¼ãƒ æ•°</div>
                <div class="stat-value" id="framesProcessed">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">éŸ³å£°ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°</div>
                <div class="stat-value" id="voiceSegments">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ç·éŸ³å£°æ™‚é–“</div>
                <div class="stat-value" id="totalVoiceTime">0ms</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">å¹³å‡VADç¢ºç‡</div>
                <div class="stat-value" id="avgVadProb">0%</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>ğŸµ éŒ²éŸ³ã•ã‚ŒãŸéŸ³å£°</h2>
        <div id="recordedAudioContainer">
            ã¾ã éŸ³å£°ãŒéŒ²éŸ³ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
        </div>
    </div>

    <div class="container">
        <h2>ğŸ“ ãƒ­ã‚°</h2>
        <div id="logContainer" class="log-container">
            ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™...
        </div>
    </div>

    <!-- Scripts -->
    <script type="module">
        // rnnoise.jsã‚’ESãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦èª­ã¿è¾¼ã¿ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«è¨­å®š
        import createRNNWasmModule from '/js/rnnoise.js';
        window.createRNNWasmModule = createRNNWasmModule;
    </script>
    <script src="/js/rnnoise-processor.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let processor = null;
        let audioContext = null;
        let mediaStream = null;
        let sourceNode = null;
        let processorNode = null;
        let isRecording = false;
        let recordedSegmentCount = 0;

        // DOMè¦ç´ 
        const elements = {
            status: document.getElementById('status'),
            initBtn: document.getElementById('initBtn'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            testBtn: document.getElementById('testBtn'),
            debugBtn: document.getElementById('debugBtn'),
            clearLogBtn: document.getElementById('clearLogBtn'),
            vadThreshold: document.getElementById('vadThreshold'),
            silenceTimeout: document.getElementById('silenceTimeout'),
            vadThresholdValue: document.getElementById('vadThresholdValue'),
            silenceTimeoutValue: document.getElementById('silenceTimeoutValue'),
            audioLevelBar: document.getElementById('audioLevelBar'),
            vadIndicator: document.getElementById('vadIndicator'),
            logContainer: document.getElementById('logContainer'),
            recordedAudioContainer: document.getElementById('recordedAudioContainer'),
            framesProcessed: document.getElementById('framesProcessed'),
            voiceSegments: document.getElementById('voiceSegments'),
            totalVoiceTime: document.getElementById('totalVoiceTime'),
            avgVadProb: document.getElementById('avgVadProb')
        };

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        function setupEventListeners() {
            elements.initBtn.addEventListener('click', initializeProcessor);
            elements.startBtn.addEventListener('click', startRecording);
            elements.stopBtn.addEventListener('click', stopRecording);
            elements.testBtn.addEventListener('click', runAudioTest);
            elements.debugBtn.addEventListener('click', toggleDebugMode);
            elements.clearLogBtn.addEventListener('click', clearLog);

            elements.vadThreshold.addEventListener('input', updateVADThreshold);
            elements.silenceTimeout.addEventListener('input', updateSilenceTimeout);

            // è¨­å®šå€¤ã®åˆæœŸè¡¨ç¤º
            updateVADThreshold();
            updateSilenceTimeout();
        }

        // åˆæœŸåŒ–å‡¦ç†
        async function initializeProcessor() {
            updateStatus('åˆæœŸåŒ–ä¸­...', 'info');
            elements.initBtn.disabled = true;

            try {
                processor = new RNNoiseProcessor();

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
                processor.onInitialized = () => {
                    updateStatus('åˆæœŸåŒ–å®Œäº†ï¼éŒ²éŸ³ã‚’é–‹å§‹ã§ãã¾ã™ã€‚', 'success');
                    elements.startBtn.disabled = false;
                    elements.testBtn.disabled = false;
                };

                processor.onVoiceDetected = () => {
                    log('ğŸ¤ éŸ³å£°é–‹å§‹æ¤œå‡º');
                };

                processor.onVoiceEnded = (audioFrames) => {
                    log(`ğŸ”Š éŸ³å£°çµ‚äº†: ${audioFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ `);
                    handleRecordedAudio(audioFrames);
                };

                processor.onAudioLevel = (level, isSpeech, vadProb) => {
                    updateVisualization(level, isSpeech, vadProb);
                };

                processor.onError = (error) => {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    updateStatus(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                };

                processor.setDebugMode(true);

                // åˆæœŸåŒ–å®Ÿè¡Œ
                const success = await processor.initialize();
                if (!success) {
                    throw new Error('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }

            } catch (error) {
                log(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateStatus(`åˆæœŸåŒ–å¤±æ•—: ${error.message}`, 'error');
                elements.initBtn.disabled = false;
            }
        }

        // éŒ²éŸ³é–‹å§‹
        async function startRecording() {
            if (isRecording || !processor) return;

            try {
                updateStatus('ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¦æ±‚ä¸­...', 'info');

                // ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 48000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // AudioContextè¨­å®š
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000
                });

                await audioContext.resume();

                // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒ¼ãƒ‰ä½œæˆ
                sourceNode = audioContext.createMediaStreamSource(mediaStream);
                processorNode = audioContext.createScriptProcessor(4096, 1, 1);

                // éŸ³å£°å‡¦ç†
                processorNode.onaudioprocess = (audioProcessingEvent) => {
                    const inputBuffer = audioProcessingEvent.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0);

                    // 480ã‚µãƒ³ãƒ—ãƒ«ï¼ˆ10msï¼‰ãšã¤å‡¦ç†
                    for (let i = 0; i < inputData.length; i += 480) {
                        const frame = inputData.slice(i, i + 480);
                        if (frame.length === 480) {
                            processor.processAudioFrame(frame);
                        }
                    }
                };

                // ãƒãƒ¼ãƒ‰æ¥ç¶š
                sourceNode.connect(processorNode);
                processorNode.connect(audioContext.destination);

                isRecording = true;
                elements.startBtn.disabled = true;
                elements.stopBtn.disabled = false;
                updateStatus('éŒ²éŸ³ä¸­... è©±ã—ã¦ãã ã•ã„ï¼', 'success');
                log('ğŸ¤ éŒ²éŸ³é–‹å§‹');

            } catch (error) {
                log(`âŒ éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateStatus(`éŒ²éŸ³é–‹å§‹å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // éŒ²éŸ³åœæ­¢
        function stopRecording() {
            if (!isRecording) return;

            try {
                // ã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }

                // ãƒãƒ¼ãƒ‰åˆ‡æ–­
                if (sourceNode) {
                    sourceNode.disconnect();
                    sourceNode = null;
                }

                if (processorNode) {
                    processorNode.disconnect();
                    processorNode = null;
                }

                // AudioContextçµ‚äº†
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                    audioContext = null;
                }

                isRecording = false;
                elements.startBtn.disabled = false;
                elements.stopBtn.disabled = true;
                updateStatus('éŒ²éŸ³åœæ­¢ã—ã¾ã—ãŸã€‚', 'info');
                log('ğŸ›‘ éŒ²éŸ³åœæ­¢');

                // å¯è¦–åŒ–ãƒªã‚»ãƒƒãƒˆ
                elements.audioLevelBar.style.width = '0%';
                elements.vadIndicator.textContent = 'ç„¡éŸ³';
                elements.vadIndicator.className = 'vad-indicator silence';

            } catch (error) {
                log(`âŒ éŒ²éŸ³åœæ­¢ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        // éŸ³å£°ãƒ†ã‚¹ãƒˆï¼ˆåˆæˆéŸ³å£°ï¼‰
        function runAudioTest() {
            if (!processor) return;

            log('ğŸ§ª éŸ³å£°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            updateStatus('éŸ³å£°ãƒ†ã‚¹ãƒˆä¸­...', 'info');

            // ãƒ†ã‚¹ãƒˆç”¨æ­£å¼¦æ³¢ç”Ÿæˆï¼ˆ1ç§’é–“ã€440Hzï¼‰
            const sampleRate = 48000;
            const duration = 1.0;
            const frequency = 440;
            const frameSize = 480;
            const totalFrames = Math.floor(sampleRate * duration / frameSize);

            let frameIndex = 0;
            const testInterval = setInterval(() => {
                if (frameIndex >= totalFrames) {
                    clearInterval(testInterval);
                    updateStatus('éŸ³å£°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    log('âœ… éŸ³å£°ãƒ†ã‚¹ãƒˆå®Œäº†');
                    return;
                }

                // æ­£å¼¦æ³¢ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
                const frame = new Float32Array(frameSize);
                for (let i = 0; i < frameSize; i++) {
                    const t = (frameIndex * frameSize + i) / sampleRate;
                    frame[i] = Math.sin(2 * Math.PI * frequency * t) * 0.3;
                }

                processor.processAudioFrame(frame);
                frameIndex++;
            }, 10); // 10msé–“éš”
        }

        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
        function toggleDebugMode() {
            if (!processor) return;

            const currentMode = processor.debugMode;
            processor.setDebugMode(!currentMode);
            elements.debugBtn.textContent = processor.debugMode ? 'ãƒ‡ãƒãƒƒã‚°OFF' : 'ãƒ‡ãƒãƒƒã‚°ON';
            log(`ğŸ› ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: ${processor.debugMode ? 'ON' : 'OFF'}`);
        }

        // ãƒ­ã‚°ã‚¯ãƒªã‚¢
        function clearLog() {
            elements.logContainer.innerHTML = '';
            if (processor) {
                processor.clearDebugLog();
            }
            log('ğŸ“ ãƒ­ã‚°ã‚¯ãƒªã‚¢');
        }

        // VADé–¾å€¤æ›´æ–°
        function updateVADThreshold() {
            const value = parseFloat(elements.vadThreshold.value);
            elements.vadThresholdValue.textContent = value.toFixed(2);

            if (processor) {
                processor.setVADThreshold(value);
            }
        }

        // ç„¡éŸ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ›´æ–°
        function updateSilenceTimeout() {
            const value = parseInt(elements.silenceTimeout.value);
            elements.silenceTimeoutValue.textContent = value + 'ms';

            if (processor) {
                processor.setSilenceTimeout(value);
            }
        }

        // å¯è¦–åŒ–æ›´æ–°
        function updateVisualization(level, isSpeech, vadProb) {
            // éŸ³å£°ãƒ¬ãƒ™ãƒ«ãƒãƒ¼
            elements.audioLevelBar.style.width = (level * 100) + '%';

            // VADã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            if (isSpeech) {
                elements.vadIndicator.textContent = `éŸ³å£° (${(vadProb * 100).toFixed(1)}%)`;
                elements.vadIndicator.className = 'vad-indicator speech';
            } else {
                elements.vadIndicator.textContent = `ç„¡éŸ³ (${(vadProb * 100).toFixed(1)}%)`;
                elements.vadIndicator.className = 'vad-indicator silence';
            }

            // çµ±è¨ˆæƒ…å ±æ›´æ–°
            if (processor) {
                const stats = processor.getStats();
                elements.framesProcessed.textContent = stats.framesProcessed;
                elements.voiceSegments.textContent = stats.voiceSegments;
                elements.totalVoiceTime.textContent = stats.totalVoiceTime + 'ms';
                elements.avgVadProb.textContent = (stats.averageVadProbability * 100).toFixed(1) + '%';
            }
        }

        // éŒ²éŸ³ã•ã‚ŒãŸéŸ³å£°å‡¦ç†
        function handleRecordedAudio(audioFrames) {
            recordedSegmentCount++;

            const wavData = processor.convertToWav(audioFrames);
            if (!wavData) {
                log('âŒ WAVå¤‰æ›ã«å¤±æ•—', 'error');
                return;
            }

            // éŸ³å£°å†ç”Ÿç”¨è¦ç´ ä½œæˆ
            const audioBlob = new Blob([wavData], { type: 'audio/wav' });
            const audioUrl = URL.createObjectURL(audioBlob);

            const audioDiv = document.createElement('div');
            audioDiv.className = 'recorded-audio';
            audioDiv.innerHTML = `
                <h4>ğŸµ éŒ²éŸ³ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ #${recordedSegmentCount}</h4>
                <p>ãƒ•ãƒ¬ãƒ¼ãƒ æ•°: ${audioFrames.length}, æ™‚é–“: ${audioFrames.length * 10}ms</p>
                <audio controls src="${audioUrl}"></audio>
                <button onclick="downloadAudio('${audioUrl}', 'voice_${recordedSegmentCount}.wav')">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            `;

            elements.recordedAudioContainer.appendChild(audioDiv);
            elements.recordedAudioContainer.scrollTop = elements.recordedAudioContainer.scrollHeight;

            log(`ğŸ’¾ éŸ³å£°ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ #${recordedSegmentCount} ä¿å­˜å®Œäº†`);
        }

        // éŸ³å£°ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        function downloadAudio(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        function updateStatus(message, type) {
            elements.status.textContent = message;
            elements.status.className = `status ${type}`;
        }

        // ãƒ­ã‚°å‡ºåŠ›
        function log(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;

            elements.logContainer.appendChild(logEntry);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', setupEventListeners);

        // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('beforeunload', () => {
            if (processor) {
                processor.destroy();
            }
            if (isRecording) {
                stopRecording();
            }
        });
    </script>
</body>
</html>